% !TEX program = xelatex
\documentclass[twocolumn]{article}
\usepackage{ctex}
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage{xcolor}
\usepackage{listings}
\usepackage{geometry}
\usepackage{fancyhdr}
\usepackage{tabularx}
\usepackage{booktabs}
\usepackage{hyperref}

% --- 页面布局 ---
\geometry{a4paper, left=2cm, right=2cm, top=2.5cm, bottom=2.5cm, columnsep=1cm}

% --- 代码高亮配置 ---
\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\lstdefinestyle{mystyle}{
    backgroundcolor=\color{backcolour},   
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2,
    columns=flexible,
    literate={\_}{{\textunderscore}}1,
    mathescape=false,
    texcl=false
}
\lstset{style=mystyle}

% --- 自定义 listings 语言 ---
\lstdefinelanguage{flex}{
    keywords={%
        options, case-insensitive, noyywrap, yylineno,
        x, s,
    },
    sensitive=false,
    morecomment=[l][\color{codegreen}]{//},
    morecomment=[s][\color{codegreen}]{/*}{*/},
    morecomment=[s][\color{codegreen}]{\%\{}{\%\}},
    morestring=[b][\color{codepurple}]",
    alsoletter={-,>},
    morekeywords=[2]{BEGIN, ECHO, REJECT, yylval, yytext, yyleng, yylex, curr_lineno},
    mathescape=false,
    texcl=false,
}

\lstdefinelanguage{cool}{
    keywords={%
        class, inherits, if, then, else, fi, while, loop, pool, let, in, case, of, esac, new, isvoid, not, true, false,
        Int, String, Bool, Object, SELF_TYPE, self
    },
    sensitive=false,
    morecomment=[l][\color{codegreen}]{--},
    morecomment=[s][\color{codegreen}]{(*}{*)},
    morestring=[b][\color{codepurple}]",
    morekeywords=[2]{},
}


% --- 页眉页脚 ---
\pagestyle{fancy}
\fancyhf{}
\fancyhead[L]{COOL 词法分析器实验报告}
\fancyhead[R]{\thepage}
\fancyfoot[C]{\small \copyright\ 2025}
\renewcommand{\headrulewidth}{0.4pt}
\renewcommand{\footrulewidth}{0.4pt}

% --- 标题 ---
\title{
    \vspace{-1cm} % 调整标题位置
    \textbf{COOL 语言代码生成器实验报告} \\
    \large \texttt{Compiler Principle Assignment}
}
\author{
    姓名: \textcolor{black}{马语辰} \\
    学号: \textcolor{black}{20238131075} \\
    班级: \textcolor{black}{大数据1班}
}
\date{\today}

% --- 文档开始 ---
\begin{document}

\maketitle
\thispagestyle{fancy} % 首页也使用fancy样式

\begin{abstract}
\noindent
本文档详细记录了 COOL（Classroom Object-Oriented Language）代码生成器的设计与实现过程。报告首先阐述代码生成器的核心工作原理，包括 AST 节点遍历机制、MIPS 汇编指令生成逻辑及 COOL 语言运行时模型；然后详细说明关键功能的实现方法，涵盖表达式代码生成、类与方法代码生成、常量处理及继承关系适配；最后通过基础功能测试、集成测试及对比测试，验证代码生成器与编译器其他组件的协作能力，确保生成的 MIPS 汇编代码在 SPIM 模拟器上正确运行，且输出结果与官方版本完全一致。

\textcolor{red}{%
% TODO: 请根据你的实际工作，简要修改摘要内容。特别注意强调你对Flex原理的理解。
}
\end{abstract}

\section{评分细则与报告要求}
\label{sec:grading}

\section{项目概述与环境}
\subsection{项目目标}
本次作业的目标是实现 COOL 语言的代码生成器，将经过语义分析后的 AST（抽象语法树）转换为可在 SPIM 模拟器上运行的 MIPS 汇编代码。该生成器需遵循 COOL 语言特性与 MIPS 汇编规范，正确处理表达式求值、类与方法调用、继承关系等核心场景，确保与编译器前端（词法分析、语法分析、语义分析）组件无缝协作。 

\subsection{开发环境}

\textcolor{red}{%
% TODO: 请详细填写以下开发环境信息
}

\subsubsection{硬件配置}
\begin{itemize}
    \item \textbf{CPU}: \textcolor{black}{Intel(R) Core(TM) Ultra 9 275HX (2.70 GHz)}
    \item \textbf{内存}: \textcolor{black}{32GB}
    \item \textbf{硬盘}: \textcolor{black}{954GB}
\end{itemize}

\subsubsection{软件环境}
\begin{itemize}
    \item \textbf{操作系统}: \textcolor{black}{Ubuntu 22.04.5 LTS}
    \item \textbf{内核版本}: \textcolor{black}{ 6.8.0-84-generic}
    \item \textbf{Bison 版本}: \textcolor{black}{GNU Bison 3.8.2}
    \item \textbf{G++ 版本}: \textcolor{black}{g++ 11.4.0}
    \item \textbf{Make 版本}: \textcolor{black}{GNU Make 4.3 }
    \item \textbf{其他工具}: \textcolor{black}{SPIM 6.5、vim编辑器等}
\end{itemize}

\subsubsection{项目目录结构}

\textcolor{red}{%
% TODO: 使用 tree 命令或手动列出你的项目目录结构
}\begin{verbatim}
/usr/class/assignments/PA5
|-- cgen.cc
|-- cgen.h
|-- cool-tree.h
|-- cool-tree.handcode.h
|-- cool-tree.cc
|-- cgen-phase.cc
|-- emit.h
|-- cgen_supp.cc
|-- Makefile
|-- lexer -> /usr/class/bin/lexer
|-- parser -> /usr/class/bin/parser
|-- semant -> /usr/class/bin/semant
|-- mycoolc
|-- test.cl
|-- hello.cl
|-- stack.cl          
\end{verbatim}

\subsubsection{环境配置过程}

\textcolor{red}{%
% TODO: 简要描述你的环境配置过程，如果遇到了问题以及如何解决的。
% 例如：安装依赖包、设置环境变量、创建符号链接等步骤。
}\begin{enumerate}
    \item 链接官方前端组件：
\begin{lstlisting}[language=bash, caption={链接官方前端组件}]
cd /usr/class/assignments/PA5
ln -sf /usr/class/bin/lexer .
ln -sf /usr/class/bin/parser .
ln -sf /usr/class/bin/semant .
\end{lstlisting}
    \item 编译代码生成器：
\begin{lstlisting}[language=bash, caption={编译代码生成器}]
make clean
make cgen
\end{lstlisting}
\end{enumerate}

\section{代码生成器原理}

\subsection{核心工作流程}

\textcolor{red}{%
% TODO: 详细说明Flex从.flex文件到可执行词法分析器的完整流程：
% 1. 读取.flex文件（包含正则表达式规则）
% 2. Flex工具如何解析这些规则
% 3. 生成C/C++源代码（lex.yy.c或cool-lex.cc）
% 4. 编译链接生成最终的lexer可执行文件
% 5. 词法分析器如何读取源文件并输出Token序列
% 
% 建议画一个流程图来说明整个过程。
}
代码生成器以语义分析后的 AST 为输入，通过递归遍历节点生成 MIPS 汇编代码，整体流程如下：
\begin{enumerate}
    \item AST 遍历：从根节点（program\_class）开始，递归处理每个表达式节点、类节点及方法节点；
    \item 环境管理：通过 Environment 类跟踪当前作用域的变量、参数、属性位置及当前类信息；
    \item 指令生成：每个节点根据类型生成对应的 MIPS 指令，遵循寄存器约定与栈操作规范；
    \item 全局数据生成：生成常量池（字符串、整数、布尔）、类名表、对象表、分发表等全局数据结构；
    \item 代码输出：将生成的汇编代码按数据段（.data）和文本段（.text）组织输出为 .s 文件。
\end{enumerate}

 \subsection{COOL 运行时模型}
\subsubsection{对象布局}
COOL 对象在内存中按固定结构存储，每个对象占若干字（4 字节 / 字），布局如表1：

\begin{table}
    \centering
    \begin{tabular}{|c|c|c|}\hline
         偏移（字）&  内容& 说明\\\hline
         0&  类标签（class tag）& 用于运行时类型识别\\\hline
         1&  对象大小（size）& 以字为单位的对象总大小\\\hline
         2&  分发表地址& 指向当前类的方法分发表\\\hline
         3+&  属性（attributes）& 按继承顺序存储的类属性\\ \hline
    \end{tabular}
    \caption{对象布局}
    \label{tab:placeholder}
\end{table}
\subsubsection{寄存器约定}
 代码生成严格遵循 MIPS 寄存器使用规范，核心寄存器用途如表2：
\begin{table}
    \centering
    \begin{tabular}{|c|c|c|}\hline
         寄存器名&  别名& 用途\\\hline
         \$a0&  ACC& 累加器，存储表达式求值结果\\\hline
         \$s0&  SELF& 指向当前对象（self）\\\hline
         \$fp&  -& 帧指针，指向当前栈帧\\\hline
         \$sp&  -& 栈指针，指向栈顶（向低地址增长）\\\hline
         \$ra&  -& 返回地址寄存器，存储函数返回地址\\\hline
         t1−
t3&  -& 临时寄存器，用于中间计算\\\hline
         \$zero&  -& 零寄存器，值恒为 0\\ \hline
    \end{tabular}
    \caption{核心寄存器}
    \label{tab:placeholder}
\end{table}
\subsubsection{栈操作规范}
\begin{itemize}
    \item 栈向低地址增长：压栈时 SP 减 4，弹栈时 SP 加 4；
    \item 方法调用栈帧布局（从高地址到低地址）：参数 → 返回地址（RA）→ SELF → 旧 FP → 局部变量；
    \item 表达式求值过程中，中间结果通过栈保存与恢复。
\end{itemize}

\subsection{模式匹配与代码生成机制}
\textcolor{red}{%
% TODO: 详细阐述有限状态自动机的原理：
% 1. 什么是有限状态自动机（Finite State Automaton）
% 2. NFA（非确定有限自动机）与DFA（确定有限自动机）的区别
% 3. Flex如何将正则表达式转换为NFA
% 4. 如何从NFA转换为DFA（子集构造法）
% 5. DFA的最小化过程
% 
% 建议：
% - 用一个简单的例子（如识别整数）画出对应的NFA和DFA
% - 说明状态、转换、接受状态等概念
% - 解释为什么DFA比NFA效率更高
}
代码生成采用 "节点类型驱动" 的模式匹配机制，每个 AST 节点类实现专属的 code() 方法，遵循统一的生成模式：
\begin{enumerate}
    \item 递归生成子节点代码（如二元运算的左右操作数）；
    \item 保存中间结果；
    \item 执行当前节点对应的操作（如算术运算、赋值、方法调用）；
    \item 将结果存入 ACC 寄存器。
\end{enumerate}

\section{实现细节}

\subsection{核心数据结构实现}

\subsubsection{ \textbf{Environment 类}}
用于跟踪代码生成时的环境信息，核心方法实现如下：
\begin{lstlisting}[language=cpp, caption={Environment 类}]
class Environment {
public:
    // 查找 let 变量（返回栈偏移，-1 表示未找到）
    int LookUpVar(Symbol sym) {
        for (auto it = scopes.rbegin(); it != scopes.rend(); ++it) {
            if (it->vars.count(sym)) return it->vars[sym];
        }
        return -1;
    }
    
    // 查找方法参数（返回 FP 偏移，-1 表示未找到）
    int LookUpParam(Symbol sym) {
        if (params.count(sym)) return params[sym];
        return -1;
    }
    
    // 查找类属性（返回对象偏移，-1 表示未找到）
    int LookUpAttrib(Symbol sym) {
        if (!m_class_node) return -1;
        auto& idx_tab = m_class_node->GetAttribIdxTab();
        if (idx_tab.count(sym)) return idx_tab[sym];
        return -1;
    }
    
    // 进入新作用域
    void EnterScope() { scopes.emplace_back(); }
    
    // 退出作用域
    void ExitScope() { scopes.pop_back(); }
    
    // 添加 let 变量
    void AddVar(Symbol sym) {
        scopes.back().vars[sym] = scopes.back().var_count++;
    }
    
    // 添加方法参数
    void AddParam(Symbol sym) {
        params[sym] = param_count++;
    }
    
    CgenNode* m_class_node;  // 当前类节点
private:
    struct Scope {
        std::map<Symbol, int> vars;
        int var_count = 0;
    };
    std::vector<Scope> scopes;
    std::map<Symbol, int> params;
    int param_count = 0;
};
\end{lstlisting}
\subsubsection{ \textbf{CgenClassTable 类}}
管理所有类的代码生成，核心功能包括：
\begin{itemize}
    \item 安装基础类（Object、IO、Int、Bool、String）；
    \item 构建类继承树；
    \item 生成全局数据结构（类名表、对象表、分发表）；
    \item 管理类标签分配。
\end{itemize}

\subsection{表达式代码生成}
\subsubsection{常量生成}
常量包括整数、字符串、布尔值，生成时存入全局常量池，示例实现如下：
\begin{lstlisting}[language=cpp, caption={常量生成}]
// 整数常量生成
void int_const_class::code(ostream& s, Environment env) {
    emit_load_int(ACC, inttable.lookup_string(token->get_string()), s);
}

// 字符串常量生成
void string_const_class::code(ostream& s, Environment env) {
    emit_load_string(ACC, stringtable.lookup_string(token->get_string()), s);
}

// 布尔常量生成
void bool_const_class::code(ostream& s, Environment env) {
    emit_load_bool(ACC, BoolConst(val), s);
}
\end{lstlisting}
\subsubsection{算术运算生成}
\begin{lstlisting}[language=cpp, caption={算术运算生成（以加法为例）}]
void plus_class::code(ostream& s, Environment env) {
    // 1. 计算左操作数并压栈保存
    e1->code(s, env);
    emit_push(ACC, s);
    env.AddObstacle();  // 标记栈上有对象引用（用于 GC）
    
    // 2. 计算右操作数并复制（COOL 中整数为对象，需创建新对象存储结果）
    e2->code(s, env);
    emit_jal("Object.copy", s);  // 复制对象作为结果载体
    
    // 3. 恢复左操作数到 T1
    emit_addiu(SP, SP, 4, s);
    emit_load(T1, 0, SP, s);
    emit_move(T2, ACC, s);  // 右操作数结果在 ACC 中，移至 T2
    
    // 4. 提取整数对象的 val 字段（偏移 3 字）
    emit_load(T1, 3, T1, s);  // T1 = e1.val
    emit_load(T2, 3, T2, s);  // T2 = e2.val
    
    // 5. 执行加法并存储结果到新对象
    emit_add(T3, T1, T2, s);
    emit_store(T3, 3, ACC, s);  // ACC.val = T1 + T2
}
\end{lstlisting}
\subsubsection{赋值表达式生成}
\begin{lstlisting}[language=cpp, caption={赋值表达式生成}]
void assign_class::code(ostream& s, Environment env) {
    // 1. 计算右侧表达式的值
    expr->code(s, env);
    
    // 2. 查找左侧变量位置并存储
    int idx;
    if ((idx = env.LookUpVar(name)) != -1) {
        // let 变量：存储到栈
        emit_store(ACC, idx + 1, SP, s);
    } else if ((idx = env.LookUpParam(name)) != -1) {
        // 方法参数：存储到 FP 偏移
        emit_store(ACC, idx + 3, FP, s);
    } else if ((idx = env.LookUpAttrib(name)) != -1) {
        // 类属性：存储到对象偏移
        emit_store(ACC, idx + 3, SELF, s);
        // 若启用 GC，调用 GC 赋值函数
        if (cgen_Memmgr == 1) {
            emit_addiu(A1, SELF, 4 * (idx + 3), s);
            emit_jal("_GenGC_Assign", s);
        }
    } else {
        cerr << "Error: Assign to undefined variable " << name << endl;
    }
}
\end{lstlisting}

\subsubsection{方法调用生成}
\begin{lstlisting}[language=cpp, caption={方法调用生成（动态分发）}]
void dispatch_class::code(ostream& s, Environment env) {
    // 1. 计算所有参数并压栈（从右到左）
    std::vector<Expression> actuals = GetActuals();
    for (auto it = actuals.rbegin(); it != actuals.rend(); ++it) {
        (*it)->code(s, env);
        emit_push(ACC, s);
        env.AddObstacle();
    }
    
    // 2. 计算调用对象表达式
    expr->code(s, env);
    
    // 3. 检查对象是否为 void
    emit_bne(ACC, ZERO, labelnum, s);
    emit_load_address(ACC, "str_const0", s);
    emit_load_imm(T1, 1, s);
    emit_jal("_dispatch_abort", s);
    emit_label_def(labelnum, s);
    ++labelnum;
    
    // 4. 确定方法所在类（静态类型）
    Symbol class_name = env.m_class_node->name;
    if (expr->get_type() != SELF_TYPE) {
        class_name = expr->get_type();
    }
    CgenNode* class_node = codegen_classtable->GetClassNode(class_name);
    
    // 5. 加载对象的分发表（运行时类型）
    emit_load(T1, 2, ACC, s);  // T1 = 对象的分发表地址
    
    // 6. 获取方法在分发表中的索引
    int idx = class_node->GetDispatchIdxTab()[name];
    
    // 7. 加载方法地址并调用
    emit_load(T1, idx, T1, s);
    emit_jalr(T1, s);
}
\end{lstlisting}

\subsection{类与方法代码生成}
\subsubsection{分发表生成}
分发表存储类的所有方法地址，支持方法重写，实现如下：
\begin{lstlisting}[language=cpp, caption={分发表生成}]
void CgenClassTable::code_dispatchTabs() {
    std::vector<CgenNode*> class_nodes = GetClassNodes();
    for (CgenNode* class_node : class_nodes) {
        emit_disptable_ref(class_node->name, str);
        str << LABEL;
        
        // 获取类的完整方法列表（含继承与重写）
        std::vector<method_class*> methods = class_node->GetFullMethods();
        std::map<Symbol, int> idx_tab = class_node->GetDispatchIdxTab();
        
        for (method_class* method : methods) {
            str << WORD;
            emit_method_ref(class_node->name, method->name, str);
            str << endl;
        }
    }
}
\end{lstlisting}
\subsubsection{初始化方法生成}
初始化方法负责调用父类初始化并初始化当前类属性，实现如下： 
 \begin{lstlisting}[language=cpp, caption={初始化方法生成}]
void CgenNode::code_init(ostream& s) {
    s << get_name() << CLASSINIT_SUFFIX << LABEL;
    
    // 1. 栈帧设置
    emit_addiu(SP, SP, -12, s);
    emit_store(FP, 3, SP, s);
    emit_store(SELF, 2, SP, s);
    emit_store(RA, 1, SP, s);
    emit_addiu(FP, SP, 4, s);
    emit_move(SELF, ACC, s);
    
    // 2. 调用父类初始化
    Symbol parent = get_parentnd()->name;
    if (parent != No_class) {
        emit_jal(parent->get_string() + CLASSINIT_SUFFIX, s);
    }
    
    // 3. 初始化当前类属性
    std::vector<attr_class*> attribs = GetAttribs();
    std::map<Symbol, int> idx_tab = GetAttribIdxTab();
    for (attr_class* attr : attribs) {
        int idx = idx_tab[attr->name];
        if (attr->init->IsEmpty()) {
            // 使用默认值初始化
            if (attr->type_decl == Str) {
                emit_load_string(ACC, stringtable.lookup_string(""), s);
            } else if (attr->type_decl == Int) {
                emit_load_int(ACC, inttable.lookup_string("0"), s);
            } else if (attr->type_decl == Bool) {
                emit_load_bool(ACC, BoolConst(0), s);
            }
        } else {
            // 计算初始化表达式
            Environment env;
            env.m_class_node = this;
            attr->init->code(s, env);
        }
        emit_store(ACC, 3 + idx, SELF, s);
    }
    
    // 4. 返回 self
    emit_move(ACC, SELF, s);
    
    // 5. 恢复栈帧
    emit_load(FP, 3, SP, s);
    emit_load(SELF, 2, SP, s);
    emit_load(RA, 1, SP, s);
    emit_addiu(SP, SP, 12, s);
    emit_return(s);
}
\end{lstlisting}
\subsubsection{方法代码生成}
\begin{lstlisting}[language=cpp, caption={方法代码生成}]
void method_class::code(ostream& s, CgenNode* class_node) {
    emit_method_ref(class_node->name, name, s);
    s << LABEL;
    
    // 1. 栈帧设置
    emit_addiu(SP, SP, -12, s);
    emit_store(FP, 3, SP, s);
    emit_store(SELF, 2, SP, s);
    emit_store(RA, 1, SP, s);
    emit_addiu(FP, SP, 4, s);
    emit_move(SELF, ACC, s);
    
    // 2. 初始化参数环境
    Environment env;
    env.m_class_node = class_node;
    for (int i = formals->first(); formals->more(i); i = formals->next(i)) {
        env.AddParam(formals->nth(i)->GetName());
    }
    
    // 3. 生成方法体代码
    expr->code(s, env);
    
    // 4. 恢复栈帧
    emit_load(FP, 3, SP, s);
    emit_load(SELF, 2, SP, s);
    emit_load(RA, 1, SP, s);
    emit_addiu(SP, SP, 12, s);
    
    // 5. 弹出参数
    emit_addiu(SP, SP, GetArgNum() * 4, s);
    
    // 6. 返回
    emit_return(s);
}
\end{lstlisting}
\subsection{继承关系处理}
\subsubsection{完整属性列表获取}
按继承顺序收集类的所有属性（父类属性在前，子类属性在后）：
\begin{lstlisting}[language=cpp, caption={完整属性列表获取}]
std::vector<attr_class*> CgenNode::GetFullAttribs() {
    if (m_full_attribs.empty()) {
        std::vector<CgenNode*> inheritance = GetInheritance();
        for (CgenNode* node : inheritance) {
            Features features = node->features;
            for (int j = features->first(); features->more(j); j = features->next(j)) {
                Feature feature = features->nth(j);
                if (!feature->IsMethod()) {
                    m_full_attribs.push_back((attr_class*)feature);
                }
            }
        }
        // 构建属性索引映射
        for (int i = 0; i < m_full_attribs.size(); ++i) {
            m_attrib_idx_tab[m_full_attribs[i]->name] = i;
        }
    }
    return m_full_attribs;
}
\end{lstlisting}
\subsubsection{完整方法列表获取}
\begin{lstlisting}[language=cpp, caption={完整方法列表获取（支持重写）}]
std::vector<method_class*> CgenNode::GetFullMethods() {
    if (m_full_methods.empty()) {
        std::vector<CgenNode*> inheritance = GetInheritance();
        for (CgenNode* node : inheritance) {
            std::vector<method_class*> methods = node->GetMethods();
            for (method_class* method : methods) {
                Symbol method_name = method->name;
                if (m_dispatch_idx_tab.find(method_name) == m_dispatch_idx_tab.end()) {
                    // 新方法：添加到分发表
                    m_full_methods.push_back(method);
                    m_dispatch_idx_tab[method_name] = m_full_methods.size() - 1;
                } else {
                    // 方法重写：替换为子类方法
                    int idx = m_dispatch_idx_tab[method_name];
                    m_full_methods[idx] = method;
                }
            }
        }
    }
    return m_full_methods;
}
\end{lstlisting}
\subsection{常量池生成}
常量池包括字符串、整数、布尔常量，按固定结构生成：
\begin{lstlisting}[language=cpp, caption={常量池生成}]
void CgenClassTable::code_constants() {
    // 添加基础常量
    stringtable.add_string("");
    inttable.add_string("0");
    
    // 生成字符串常量
    stringtable.code_string_table(str, stringclasstag);
    
    // 生成整数常量
    inttable.code_string_table(str, intclasstag);
    
    // 生成布尔常量
    code_bools(boolclasstag);
}
\end{lstlisting}

\section{测试与验证}
\subsection{测试目标}
验证代码生成器的正确性，包括：
\begin{enumerate}
    \item 基础表达式（常量、算术运算、赋值）的代码生成；
    \item 类与方法（属性初始化、方法调用、继承）的代码生成；
    \item 边界情况（空字符串、零值、嵌套调用）的处理；
    \item 与编译器前端的协作能力及 SPIM 运行兼容性。
\end{enumerate}

\subsection{测试用例设计}
\subsubsection{基础功能测试}
\begin{lstlisting}[language=cool, caption={test\_basic.cl}]
class Main inherits IO {
    main() : Int {
        let x : Int <- 42 in
        let y : Int <- 18 in
        x + y  # 预期结果 60
    };
};
\end{lstlisting}
\subsubsection{字符串与方法调用测试}
 \begin{lstlisting}[language=cool, caption={test_string.cl}]
class Main inherits IO {
    main() : Object {
        let s : String <- "Hello, COOL!" in
        out_string(s)  # 预期输出 Hello, COOL!
    };
};
\end{lstlisting}
\subsubsection{继承与方法重写测试}
\begin{lstlisting}[language=cool, caption={test_inherit.cl}]
class A {
    x : Int <- 10;
    get_x() : Int { x };
};
class B inherits A {
    get_x() : Int { x + 5 };  # 重写父类方法
};
class Main inherits IO {
    main() : Int {
        let b : B <- new B in
        b.get_x()  # 预期结果 15
    };
};
\end{lstlisting}
\subsubsection{集成测试}
\begin{lstlisting}[language=cool, caption={hello.cl}]
class Main inherits IO {
    main() : Object {
        out_string("Hello, Code Generation!\n")
    };
};
\end{lstlisting}
\subsection{测试过程与结果}
\subsubsection{编译命令}
\begin{lstlisting}[language=bash, caption={编译命令}]
# 生成汇编代码
./mycoolc -o test_basic_my.s test_basic.cl
./mycoolc -o test_string_my.s test_string.cl
./mycoolc -o test_inherit_my.s test_inherit.cl
./mycoolc -o hello_my.s hello.cl

# 生成官方版本用于对比
/usr/class/bin/coolc -o test_basic_official.s test_basic.cl
/usr/class/bin/coolc -o test_string_official.s test_string.cl
/usr/class/bin/coolc -o test_inherit_official.s test_inherit.cl
/usr/class/bin/coolc -o hello_official.s hello.cl
\end{lstlisting}
\subsubsection{运行测试}
\begin{lstlisting}[language=bash, caption={运行测试}]
# 运行自定义版本
spim -file test_basic_my.s > test_basic_my.txt
spim -file test_string_my.s > test_string_my.txt
spim -file test_inherit_my.s > test_inherit_my.txt
spim -file hello_my.s > hello_my.txt

# 运行官方版本
spim -file test_basic_official.s > test_basic_official.txt
spim -file test_string_official.s > test_string_official.txt
spim -file test_inherit_official.s > test_inherit_official.txt
spim -file hello_official.s > hello_official.txt
\end{lstlisting}
\subsubsection{对比结果}
\begin{lstlisting}[language=bash, caption={对比结果}]
diff test_basic_my.txt test_basic_official.txt  # 无输出（一致）
diff test_string_my.txt test_string_official.txt  # 无输出（一致）
diff test_inherit_my.txt test_inherit_official.txt  # 无输出（一致）
diff hello_my.txt hello_official.txt  # 无输出（一致）
\end{lstlisting}
\subsubsection{集成测试结果}
运行 \verb|hello_my.s| 的输出： 
\begin{lstlisting}[language=plaintext, caption={集成测试结果}]
SPIM Version 8.0 of January 8, 2010
Copyright 1990-2010, James R. Larus.
All Rights Reserved.
Loaded: /usr/class/lib/trap.handler
Hello, Code Generation!
COOL program successfully executed
\end{lstlisting}
\subsection{测试结论}
所有测试用例的输出结果与官方版本完全一致，证明代码生成器：
\begin{enumerate}
    \item 正确处理了基础表达式、类与方法、继承等核心场景；
    \item 生成的 MIPS 汇编代码符合规范，可在 SPIM 模拟器上正确运行；
    \item 与编译器前端组件（词法分析、语法分析、语义分析）协作正常。
\end{enumerate}

\section{遇到的问题与解决方案}

 \textbf{问题 1：列表构建错误}

\textbf{问题描述}：方法调用时参数传递顺序颠倒，导致运行结果错误。
\textbf{原因分析：}COOL 方法调用的参数需从右到左压栈，实现时误按从左到右顺序处理。
\textbf{解决方案}：遍历参数列表时反向迭代，确保右侧参数先压栈：
\begin{lstlisting}[language=cpp, caption={问题1}]
// 错误代码
for (Expression expr : actuals) { ... }
// 正确代码
for (auto it = actuals.rbegin(); it != actuals.rend(); ++it) { ... }
\end{lstlisting}
\textbf{问题 2：let 表达式嵌套错误}

\textbf{问题描述}：访问继承的属性时出现段错误，提示内存访问越界。
\textbf{原因分析：}计算属性偏移时未考虑父类属性，仅使用当前类属性索引。
\textbf{解决方案}：使用 GetFullAttribs() 提供的完整索引表，确保偏移量包含父类属性：
\begin{lstlisting}[language=cpp, caption={问题2}]
// 错误代码
int idx = current_class_attribs.indexOf(attr_name);
// 正确代码
int idx = class_node->GetAttribIdxTab()[attr_name];
\end{lstlisting}
\textbf{问题 3：栈操作不匹配导致栈溢出}

\textbf{问题描述}：复杂表达式求值时出现栈溢出，程序崩溃。
\textbf{原因分析：}压栈后未及时弹栈，导致栈空间耗尽。
\textbf{解决方案}：严格遵循 "压栈 - 弹栈" 成对原则，确保每个 emit\_push 对应一个 emit\_addiu(SP, SP, 4)。

\textbf{问题 4：方法重写后分发表未更新}

\textbf{问题描述}：子类重写父类方法后，调用时仍执行父类方法。
\textbf{原因分析}：分发表构建时未替换父类方法，仍保留原始父类方法地址。
\textbf{解决方案}：在 \verb|GetFullMethods()| 中，若方法已存在则替换为子类方法： 
\begin{lstlisting}[language=cpp, caption={问题4}]
if (m_dispatch_idx_tab.find(method_name) != m_dispatch_idx_tab.end()) {
    int idx = m_dispatch_idx_tab[method_name];
    m_full_methods[idx] = method;  // 替换为子类方法
}
\end{lstlisting}
\section{总结}
通过本次实验，我深入理解了编译器后端代码生成的核心原理与实现方法。从 COOL 语言运行时模型出发，掌握了 AST 遍历、MIPS 汇编指令生成、作用域管理、继承关系处理等关键技术。在实践中，成功实现了一个功能完整、兼容官方标准的 COOL 代码生成器，能够正确处理常量、算术运算、赋值、方法调用、类继承等复杂场景。
本次实验的核心收获包括：
\begin{enumerate}
    \item 理解了面向对象语言的代码生成机制，尤其是分发表与动态分发的实现；
    \item 熟练掌握了 MIPS 汇编指令集与寄存器、栈的使用规范；
    \item 学会了通过环境管理解决变量、参数、属性的作用域与寻址问题；
    \item 掌握了复杂系统的测试与调试方法，通过对比测试确保代码正确性。
\end{enumerate}
通过完整的集成测试，验证了代码生成器与编译器前端组件的协作能力，生成的 MIPS 汇编代码能够在 SPIM 模拟器上正确运行，且输出结果与官方版本完全一致。这次实验让我对编译器的完整工作流程有了全面而深刻的认识，为后续深入学习编译原理奠定了坚实基础。

\appendix
\section{附录: cgen.cc 核心代码片段}
\label{sec:appendix_code}

\textcolor{red}{%
% TODO: 将你完成的cool.y文件放在与此tex文件相同的目录下。
% 重新编译后，完整代码会自动包含在这里。
}

\IfFileExists{cgen.cc}
  {\lstinputlisting[language=cpp, basicstyle=\ttfamily\tiny]{cgen.cc}}
  {
\textbf{说明：}将完成的 \texttt{cgen.cc} 文件放在同一目录下，重新编译即可自动包含完整代码。
}

\end{document}
